//----------------------------------------------------------------
// File: patRandomWalk.cc
// Author: Michel Bierlaire
// Creation: Tue May 19 17:12:26 2009
//----------------------------------------------------------------

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include "patDisplay.h"
#include "patRandomWalk.h"
#include "patString.h"
#include "patErrMiscError.h"
#include "patNetwork.h"
#include "patPower.h"
#include "patDiscreteDistribution.h"

patRandomWalk::patRandomWalk(patReal a, patReal b, patULong seed) :
  patPathGenerationAlgo(patString("Random walk")),
  kumaA(a),
  kumaB(b),
  randomNumbersGenerator(seed) {
  
}

pair<patPath,patReal> patRandomWalk::generateNextPath(patNetwork* theNetwork, patOd theOd, patError*& err) {


  patPath thePath ;
  thePath.name = patString("Generated by random walk") ;
  thePath.od = theOd ;
  patULong currentNode = theOd.orig ;
  patReal logProba = 0.0 ;
  thePath.listOfNodes.push_back(theOd.orig) ;
  while (currentNode != theOd.dest) {
    pair<patULong,patReal> result = 
      getNextNodeInRandomWalk(theNetwork,
			      currentNode,
			      theOd.dest,
			      err) ;
    if (err != NULL) {
      WARNING(err->describe()) ;
      return pair<patPath,patReal>() ;
    }
    //    DEBUG_MESSAGE("Node : " << result.first) ;
    thePath.listOfNodes.push_back(result.first) ;
    //    DEBUG_MESSAGE("Proba node: " << result.second) ;
    logProba += log(result.second) ;
    currentNode = result.first ;
  }

  //  DEBUG_MESSAGE("Proba path: " << exp(logProba)) ;
  return pair<patPath,patReal>(thePath,exp(logProba)) ;
  
}



pair<patULong,patReal> patRandomWalk::getNextNodeInRandomWalk(patNetwork* theNetwork, 
							      patULong currentNode, 
							      patULong dest, 
							      patError*& err) {

  if (currentNode == dest) {
    return pair<patULong,patReal>(patBadId,0.0) ;
  }

  //  DEBUG_MESSAGE("Current node: " << currentNode) ;
  
  patNode* theCurrentNode = theNetwork->getNodeFromUserId(currentNode) ;
  patIterator<patULong>* outgoingNodes = theCurrentNode->getSuccessors() ;

  patOd theOd(currentNode,dest) ;

  // The shortest path cost

  patReal theShortest = theNetwork->getShortestPathCost(theOd,err) ;
  if (err != NULL) {
    WARNING(err->describe()) ;
    return pair<patULong,patReal>();
  }

  
  // Loop on the outgoing edges, and compute the cost of each shortest paths.

  vector<patReal> proba ;
  vector<patULong> theNodes ;

  patReal total(0.0) ;

  for (outgoingNodes->first() ;
       !outgoingNodes->isDone() ;
       outgoingNodes->next()) {
    patULong theNextNode = outgoingNodes->currentItem() ;
    patArc* theArc = theNetwork->getArcFromNodesUserId(theCurrentNode->getUserId(),theNextNode) ;
    if (theArc == NULL) {
      stringstream str ;
      str << "Could not find the arc from node " << theCurrentNode->getUserId() << " to node " << theNextNode ;
      err = new patErrMiscError(str.str()) ;
      WARNING(err->describe()) ;
      return pair<patULong,patReal>() ;
    }


    theOd.orig = theNextNode ;
    patReal spCost = theNetwork->getShortestPathCost(theOd,err) ;
    if (err != NULL) {
      WARNING(err->describe()) ;
      return pair<patULong,patReal>();
    }
    if (spCost == patMaxReal) {
      // OD not connected
    }
    else {
    
      patReal diff = patReal(theShortest) - patReal(spCost) - patReal(theArc->generalizedCost) ;
      if (diff > patSQRT_EPSILON) {
	stringstream str ;
	str << "Ratio should be lesser or equal to 1, and is " << patReal(theShortest) << " / (" <<  patReal(spCost) << " + " <<  patReal(theArc->generalizedCost) << ")" ;
	err = new patErrMiscError(str.str()) ;
	WARNING(err->describe()) ;
	return pair<patULong,patReal>();
      }
      patReal theRatio = patReal(theShortest) / patReal(spCost + theArc->generalizedCost) ;
      
      patReal kuma = 1.0 - patPower(1.0 - patPower(theRatio,kumaA) , kumaB) ;
      if (!finite(kuma)) {
	kuma = 0.0 ;
      }
      
      total += kuma ;
      //      DEBUG_MESSAGE("Next node: " << theNextNode << " Proba: " << kuma) ;
      proba.push_back(kuma) ;
      theNodes.push_back(theNextNode) ;
    }
  }

  if (proba.empty()) {
    stringstream str ;
    str << "Node " << currentNode << " is a dead end. No outgoing arc. Impossible to reach destination " << dest ;
    err = new patErrMiscError(str.str()) ;
    WARNING(err->describe()) ;
    return pair<patULong,patReal>();
  }
  
  for (vector<patReal>::iterator i = proba.begin() ;
       i != proba.end() ;
       ++i) {
    *i /= total ;
  }


  unsigned long selectId = 
    patDiscreteDistribution(&proba,
			    &randomNumbersGenerator,patTRUE)() ;
  
  //DEBUG_MESSAGE("SELECT NODE " << theNodes[selectId] << " with proba " << proba[selectId]) ;


  return pair<patULong,patReal>(theNodes[selectId],proba[selectId]) ;
  
}

void patRandomWalk::setKumaParameters(patReal a, patReal b) {
  kumaA = a ;
  kumaB = b ;
}

patString patRandomWalk::getReport() {
  
}

patReal patRandomWalk::probability(patPath aPath, patNetwork* aNetwork, patError*& err) {
  patReal logProba = 0.0 ;
  for (patULong i = 0 ; 
       i < aPath.listOfNodes.size()-1 ;
       ++i) {
    patULong v = aPath.listOfNodes[i] ;
    patULong w = aPath.listOfNodes[i+1] ;
    patNode* theCurrentNode = aNetwork->getNodeFromUserId(v) ;
    patIterator<patULong>* outgoingNodes = theCurrentNode->getSuccessors() ;
    patOd theOd(v,aPath.od.dest) ;
    patReal theShortest = aNetwork->getShortestPathCost(theOd,err) ;
    if (err != NULL) {
      WARNING(err->describe()) ;
      return patReal() ;
    }

    // Loop on the outgoing edges, and compute the cost of each shortest paths.
    
    vector<patReal> proba ;
    vector<patULong> theNodes ;
    
    patReal total(0.0) ;


    patReal numerator ;
    for (outgoingNodes->first() ;
	 !outgoingNodes->isDone() ;
	 outgoingNodes->next()) {
      patULong theNextNode = outgoingNodes->currentItem() ;
      patArc* theArc = aNetwork->getArcFromNodesUserId(theCurrentNode->getUserId(),theNextNode) ;
      if (theArc == NULL) {
	stringstream str ;
	str << "Could not find the arc from node " << theCurrentNode->getUserId() << " to node " << theNextNode ;
	err = new patErrMiscError(str.str()) ;
	WARNING(err->describe()) ;
	return patReal() ;
      }
      
      
      theOd.orig = theNextNode ;
      patReal spCost = aNetwork->getShortestPathCost(theOd,err) ;
      if (err != NULL) {
	WARNING(err->describe()) ;
	return patReal() ;
      }
      
      if (spCost == patMaxReal) {
	// OD not connected
      }
      else {
	
	patReal diff = patReal(theShortest) - patReal(spCost) - patReal(theArc->generalizedCost) ;
	if (diff > patSQRT_EPSILON) {
	  stringstream str ;
	  str << "Ratio should be lesser or equal to 1, and is " << patReal(theShortest) << " / (" <<  patReal(spCost) << " + " <<  patReal(theArc->generalizedCost) << ")" ;
	  err = new patErrMiscError(str.str()) ;
	  WARNING(err->describe()) ;
	  return patReal();
	}
	patReal theRatio = patReal(theShortest) / patReal(spCost + theArc->generalizedCost) ;
	
	patReal kuma = 1.0 - patPower(1.0 - patPower(theRatio,kumaA) , kumaB) ;
	if (!finite(kuma)) {
	  kuma = 0.0 ;
	}
	
	if (theNextNode == w) {
	  numerator = kuma ;
	}
	
	total += kuma ;
	proba.push_back(kuma) ;
	theNodes.push_back(theNextNode) ;
      }
    }
    
    logProba += log(numerator) - log(total) ;

  }
  return exp(logProba) ;
}
