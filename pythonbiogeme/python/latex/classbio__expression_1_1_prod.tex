\hypertarget{classbio__expression_1_1_prod}{}\section{bio\+\_\+expression.\+Prod Class Reference}
\label{classbio__expression_1_1_prod}\index{bio\+\_\+expression.\+Prod@{bio\+\_\+expression.\+Prod}}


Class representing the product of the same expression applied to a list of data.  


Inheritance diagram for bio\+\_\+expression.\+Prod\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classbio__expression_1_1_prod}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classbio__expression_1_1_prod_aefc065fd66e564921e002287720ca15f}{\+\_\+\+\_\+init\+\_\+\+\_\+} (self, term, iterator\+Name, positive=False)
\item 
def {\bfseries get\+Expression} (self)\hypertarget{classbio__expression_1_1_prod_a40185838fd0be61cff5c5dc7e5142e88}{}\label{classbio__expression_1_1_prod_a40185838fd0be61cff5c5dc7e5142e88}

\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
{\bfseries function}\hypertarget{classbio__expression_1_1_prod_ad701a84ab99b64715360bd7cd3f23b72}{}\label{classbio__expression_1_1_prod_ad701a84ab99b64715360bd7cd3f23b72}

\item 
{\bfseries iterator\+Name}\hypertarget{classbio__expression_1_1_prod_a44847763ff32dfe95d002b49e733bfc2}{}\label{classbio__expression_1_1_prod_a44847763ff32dfe95d002b49e733bfc2}

\item 
{\bfseries positive}\hypertarget{classbio__expression_1_1_prod_a2b418ff03d043dd99bca62aef5b42962}{}\label{classbio__expression_1_1_prod_a2b418ff03d043dd99bca62aef5b42962}

\item 
{\bfseries operator\+Index}\hypertarget{classbio__expression_1_1_prod_abc58ca6ede4902b55b96afb0ecaf22c7}{}\label{classbio__expression_1_1_prod_abc58ca6ede4902b55b96afb0ecaf22c7}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Class representing the product of the same expression applied to a list of data. 

The concept of iterators identifies a sequence such that, for each instance, the value of the variables is read from the data file, and an expression can be evaluated. The two expressions described in this section consider one iterator and one expression, and evaluate the expression for each instance defined by the iterator. A product can then be computed. The following example computes the loglikelihood for a model with panel data. 
\begin{DoxyCode}
1 metaIterator(\textcolor{stringliteral}{'personIter'},\textcolor{stringliteral}{'\_\_dataFile\_\_'},\textcolor{stringliteral}{'panelObsIter'},\textcolor{stringliteral}{'Id'})
2 rowIterator(\textcolor{stringliteral}{'panelObsIter'},\textcolor{stringliteral}{'personIter'})
3 
4 condProbIndiv = Prod(prob,\textcolor{stringliteral}{'panelObsIter'})
5 probIndiv = MonteCarlo(condProbIndiv)
6 loglikelihood = Sum(log(probIndiv),\textcolor{stringliteral}{'personIter'})
\end{DoxyCode}
 The iterator person\+Iter iterates on each individual in the file, characterized by the identifier Id. The iterator panel\+Obs\+Iter iterates on the observations (that is, the rows in the data file) associated with the current individual.

Assuming that prob is the likelihood of the observation in one raw, for a given set of draws, the following quantities are computed\+:
\begin{DoxyItemize}
\item The conditional probability of the sequence of observations for the current individual n\+:
\end{DoxyItemize}

\[ \mbox{condProbIndiv} = P(y_1,\ldots,y_T|\xi_n) = \prod_t P(y_t|\xi_n)\]


\begin{DoxyItemize}
\item The unconditional probability of the sequence of observations for the current individual n\+: \[ \mbox{probIndiv} = \int_{\xi_n}P(y_1,\ldots,y_T|\xi_n) \approx \sum_r P(y_1,\ldots,y_T|\xi_r) / R \] where $\xi_r$ are the R draws generated from $\xi_n$.
\item The loglikelihood for all individuals in the sample\+: \[ \mbox{loglikelihood} = \sum_n \log(\sum_r P(y_1,\ldots,y_T|\xi_r) / R) \] 
\end{DoxyItemize}

Definition at line 689 of file bio\+\_\+expression.\+py.



\subsection{Constructor \& Destructor Documentation}
\index{bio\+\_\+expression\+::\+Prod@{bio\+\_\+expression\+::\+Prod}!\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}!bio\+\_\+expression\+::\+Prod@{bio\+\_\+expression\+::\+Prod}}
\subsubsection[{\texorpdfstring{\+\_\+\+\_\+init\+\_\+\+\_\+(self, term, iterator\+Name, positive=\+False)}{__init__(self, term, iteratorName, positive=False)}}]{\setlength{\rightskip}{0pt plus 5cm}def bio\+\_\+expression.\+Prod.\+\_\+\+\_\+init\+\_\+\+\_\+ (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{term, }
\item[{}]{iterator\+Name, }
\item[{}]{positive = {\ttfamily False}}
\end{DoxyParamCaption}
)}\hypertarget{classbio__expression_1_1_prod_aefc065fd66e564921e002287720ca15f}{}\label{classbio__expression_1_1_prod_aefc065fd66e564921e002287720ca15f}

\begin{DoxyParams}{Parameters}
{\em term} & any valid bio\+\_\+expression \\
\hline
{\em iterator\+Name} & name of an iterator already defined \\
\hline
{\em positive} & Set it to True if all factors of the product are strictly positive. In that case, it will be computed as \[ \prod_r x_r = \exp(\sum_r \ln x_r)\] \\
\hline
\end{DoxyParams}


Definition at line 695 of file bio\+\_\+expression.\+py.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{bio__expression_8py}{bio\+\_\+expression.\+py}\end{DoxyCompactItemize}
